ggplot(data=data.m, aes(x=nmc, y=value, fill=Current_status)) +
geom_bar(stat="identity")+
# geom_text(aes(y=label_ypos, label=len), vjust=1.6,
#          color="white", size=3.5)+
#scale_fill_brewer(palette="Paired")+
theme_minimal()+
scale_x_continuous(breaks=seq(1,17,2))+
ggtitle("LIFE study summary")+
xlab("Number of menstrucal cycle")+
ylab("Number of people")
dev.off()
library(sas7bdat)
install.packages("sas7bdat")
library(sas7bdat)
setwd('/users/hzhang1/mixture_approach')
library(sas7bdat)
setwd('/Users/zhangh24/GoogleDrive/project/Tom/mixture_approach_estimate_population_value/mixture_approach')
data <- read.sas7bdat('./data/LIFE_DATA/dailycycle.sas7bdat')
data.baseline <- read.sas7bdat('./data/LIFE_DATA/baseline.sas7bdat')
library(data.table)
data.sum <- as.data.frame(fread('./data/LIFE_DATA/summary_table.csv',header=T))
data.sum <- data.sum[-1,]
data.sum[,4] <- as.numeric(data.sum[,4])
data.sum[,3] <- as.numeric(data.sum[,3])
data.sum[,2] <- as.numeric(data.sum[,2])
data.sum$still_in_study <- data.sum[,4]-data.sum[,3]-data.sum[,2]
colnames(data.sum)[6] <- "Still in study"
n.sub <- length(table(data$ID))
data.clean <- data.sum[,c(1,2,3,6)]
data.m <- melt(data.clean,id="Number of menstrual cycles")
colnames(data.m)[1] <- "nmc"
colnames(data.m)[2] <- "Current_status"
library(ggplot2)
ggplot(data=data.m, aes(x=nmc, y=value, fill=Current_status)) +
geom_bar(stat="identity")+
# geom_text(aes(y=label_ypos, label=len), vjust=1.6,
#          color="white", size=3.5)+
#scale_fill_brewer(palette="Paired")+
theme_minimal()+
scale_x_continuous(breaks=seq(1,17,2))+
ggtitle("LIFE study summary")+
xlab("Number of menstrucal cycle")+
ylab("Number of people")
head(data.m)
library(sas7bdat)
setwd('/Users/zhangh24/GoogleDrive/project/Tom/mixture_approach_estimate_population_value/mixture_approach')
data <- read.sas7bdat('./data/LIFE_DATA/dailycycle.sas7bdat')
data.baseline <- read.sas7bdat('./data/LIFE_DATA/baseline.sas7bdat')
n.sub <- length(table(data$ID))
ID <- unique(data$ID)
ID <- sort(ID)
obs <- rep(0,n.sub)
N <- rep(0,n.sub)
for(i in 1:n.sub){
print(i)
idx <- which(data$ID==ID[i])
obs[i] <- max(data[idx,]$preg,na.rm=T)
N[i] <- max(data[idx,]$method5,na.rm=T)
}
table(obs,N)
head(data)
head(data)
data[1:100,]
i <- 1
idx <- which(data$ID==ID[i])
data[idx,]
data[idx,1:4]
data[idx,1:5]
i <- 1
i <- 2
idx <- which(data$ID==ID[i])
obs[i] <- max(data[idx,]$preg,na.rm=T)
N[i] <- max(data[idx,]$method5,na.rm=T)
data[idx,1:5]
head(data)
head(data_sum)
head(data.sum)
N
length(N)
head(obs)
data[idx,1:5]
head(obs)
head(N)
i <- 3
idx <- which(data$ID==ID[i])
obs[i] <- max(data[idx,]$preg,na.rm=T)
N[i] <- max(data[idx,]$method5,na.rm=T)
data[idx,1:5]
i <- 4
print(i)
idx <- which(data$ID==ID[i])
obs[i] <- max(data[idx,]$preg,na.rm=T)
N[i] <- max(data[idx,]$method5,na.rm=T)
data[idx,1:5]
idx <- which(N==1&obs==0)
idx
i <- 92
print(i)
idx <- which(data$ID==ID[i])
obs[i] <- max(data[idx,]$preg,na.rm=T)
N[i] <- max(data[idx,]$method5,na.rm=T)
data[idx,1:5]
N[92]
obs[92]
idx <- which(N==0&obs==1)
idx <- which(data$ID==ID[i])
idx <- which(N==0&obs==1)
idx
i <- 23
print(i)
idx <- which(data$ID==ID[i])
data[idx,1:5]
sum(obs)
sum(n)
sum(N)
library(sas7bdat)
setwd('/Users/zhangh24/GoogleDrive/project/Tom/mixture_approach_estimate_population_value/mixture_approach')
data <- read.sas7bdat('./data/LIFE_DATA/dailycycle.sas7bdat')
data.baseline <- read.sas7bdat('./data/LIFE_DATA/baseline.sas7bdat')
library(data.table)
data.sum <- as.data.frame(fread('./data/LIFE_DATA/summary_table.csv',header=T))
data.sum <- data.sum[-1,]
data.sum[,4] <- as.numeric(data.sum[,4])
data.sum[,3] <- as.numeric(data.sum[,3])
data.sum[,2] <- as.numeric(data.sum[,2])
data.sum$still_in_study <- data.sum[,4]-data.sum[,3]-data.sum[,2]
colnames(data.sum)[6] <- "Still in study"
n.sub <- length(table(data$ID))
data.clean <- data.sum[,c(1,2,3,6)]
data.m <- melt(data.clean,id="Number of menstrual cycles")
colnames(data.m)[1] <- "nmc"
colnames(data.m)[2] <- "Current_status"
library(ggplot2)
ggplot(data=data.m, aes(x=nmc, y=value, fill=Current_status)) +
geom_bar(stat="identity")+
# geom_text(aes(y=label_ypos, label=len), vjust=1.6,
#          color="white", size=3.5)+
#scale_fill_brewer(palette="Paired")+
theme_minimal()+
scale_x_continuous(breaks=seq(1,17,2))+
ggtitle("LIFE study summary")+
xlab("Number of menstrucal cycle")+
ylab("Number of people")
ID <- unique(data$ID)
ID <- sort(ID)
obs <- rep(0,n.sub)
N <- rep(0,n.sub)
for(i in 1:n.sub){
print(i)
idx <- which(data$ID==ID[i])
obs[i] <- max(data[idx,]$preg,na.rm=T)
N[i] <- max(data[idx,]$method5,na.rm=T)
}
data.temp <- cbind(ID,obs,N)
data.com <- merge(data.temp,data.baseline,by.x="ID",by.y="ID")
library(tidyverse)
data.com <- data.com %>% mutate(
age_average = (Age_m+Age_f)/2,
age_diff = abs(Age_m-Age_f)/2
)
library(tidyverse)
install.packages("tidyverse")
install.packages("tidyverse")
install.packages("tidyverse")
install.packages("tidyverse")
library(tidyverse)
library(dplyr)
data.com <- data.com %>% mutate(
age_average = (Age_m+Age_f)/2,
age_diff = abs(Age_m-Age_f)/2
)
###############take out the first cycle
idx <- which(data.com$N!=0)
data.clean <- data.com[idx,]
dim(data.clean)
n.couple <- nrow(data.clean)
n.cycle <- sum(data.clean$N)
Y <- rep(0,n.cycle)
age_averge.cycle <- rep(0,n.cycle)
age_diff.cycle <- rep(0,n.cycle)
ID.cycle <- rep(0,n.cycle)
temp <- 0
for(i in 1:n.couple){
print(i)
if(data.clean$obs[i]==1){
Y[temp] = 1
}
age_averge.cycle[temp+(1:data.clean$N[i])] <- data.clean$age_average[i]
age_diff.cycle[temp+(1:data.clean$N[i])] <- data.clean$age_diff[i]
ID.cycle[temp+(1:data.clean$N[i])] <- data.clean$ID[i]
temp <- temp+data.clean$N[i]
}
##############original estimate without any confounder adjustment
NPML_logistic_function(data.com$N,cbind(data.com$age_average,data.com$age_diff),tol,maxit,K,data.com$obs)
for(i in 1:n.sub){
print(i)
idx <- which(data$ID==ID[i])
obs[i] <- max(data[idx,]$preg,na.rm=T)
N[i] <- max(data[idx,]$method5,na.rm=T)
}
table(obs,N)
idx.new <- which(N!=0)
obs.new <- obs[idx.new]
N.new <- N[idx.new]
N <- N.new
cen <- obs.new
new.data <- as.data.frame(table(N,cen))
head(new.data)
###########take out people with no complete menstrcucal cycle
table(obs,N)
idx.new <- which(N!=0)
obs.new <- obs[idx.new]
N.new <- N[idx.new]
N <- N.new
cen <- obs.new
new.data <- as.data.frame(table(N,cen))
#################new data to analyze
#################N is the number of menstrual cycle
#################cen
new.data <- as.data.frame(table(N,cen))
head(new.data)
new.data
###########take out people with no complete menstrcucal cycle
table(obs,N)
###########take out people with no complete menstrcucal cycle
table(obs,N)
obs <- rep(0,n.sub)
N <- rep(0,n.sub)
for(i in 1:n.sub){
print(i)
idx <- which(data$ID==ID[i])
obs[i] <- max(data[idx,]$preg,na.rm=T)
N[i] <- max(data[idx,]$method5,na.rm=T)
}
data.temp <- cbind(ID,obs,N)
table(N,ob)
table(N,obs)
for(i in 1:n.sub){
print(i)
idx <- which(data$ID==ID[i])
obs[i] <- max(data[idx,]$preg,na.rm=T)
N[i] <- max(data[idx,]$method5,na.rm=T)
}
###########take out people with no complete menstrcucal cycle
table(obs,N)
idx.new <- which(N!=0)
obs.new <- obs[idx.new]
N.new <- N[idx.new]
table(obs.new,N.new)
sum(N.new)
N <- N.new
cen <- obs.new
#################new data to analyze
#################N is the number of menstrual cycle
#################cen
new.data <- as.data.frame(table(N,cen))
new.data
new.data <- as.data.frame(table(N,cen))
risk <- rep(0,max(N))
for(i in 1:max(N)){
if(i==1){
idx <- which(new.data[,1]==i)
remove <- sum(new.data[idx,3])
risk[i] <- length(N)
}else{
idx <- which(new.data[,1]==i)
remove <- sum(new.data[idx,3])
risk[i] <- risk[i-1]-remove
}
}
sur.data <- cbind(table(N,cen),risk)
K.estimate <- sur.data[,2]/risk
new.data
censor.rate <- sum(cen)/length(cen)
censor.rate
cen
NPML.estimate <- NPMLEstimateFunction(N,cen)
library(PAV)
install_github("andrewhaoyu/PAV")
library(devtools)
install_github("andrewhaoyu/PAV")
library(PAV)
NPML.estimate <- NPMLEstimateFunction(N,cen)
NPML.estimate
################Stratified estimate
StratEst <- StratEstimateFunction(Nt,cen)
M <- 1
Nt <- N
################Stratified estimate
StratEst <- StratEstimateFunction(Nt,cen)
StratEst
################NPML estimate with no covariates adjustment
NPMLEst <- NPMLEstimateFunction(N,cen)[[3]]
N <- Nt
###############beta prior estimate
begin <- c(0.3804882,20.0296849)
fit <-  optim(par = begin,fn=BetaGeometricLikehood,gr=LogL.Derivatives,lower=c(0.0005,0.05),upper=c(0.9995,10000),method="L-BFGS-B",control=list(fnscale=-1))
BetaEst <- fit$par[1]
like <- BetaGeometricLikehood(fit$par)
BetaEst
NPML.estimate[[1]]
NPML.estimate[[2]]
BetaEst
fit$par
library(sas7bdat)
setwd('/Users/zhangh24/GoogleDrive/project/Tom/mixture_approach_estimate_population_value/mixture_approach')
data <- read.sas7bdat('./data/LIFE_DATA/dailycycle.sas7bdat')
data.baseline <- read.sas7bdat('./data/LIFE_DATA/baseline.sas7bdat')
library(data.table)
data.sum <- as.data.frame(fread('./data/LIFE_DATA/summary_table.csv',header=T))
data.sum <- data.sum[-1,]
data.sum[,4] <- as.numeric(data.sum[,4])
data.sum[,3] <- as.numeric(data.sum[,3])
data.sum[,2] <- as.numeric(data.sum[,2])
data.sum$still_in_study <- data.sum[,4]-data.sum[,3]-data.sum[,2]
colnames(data.sum)[6] <- "Still in study"
n.sub <- length(table(data$ID))
data.clean <- data.sum[,c(1,2,3,6)]
data.m <- melt(data.clean,id="Number of menstrual cycles")
colnames(data.m)[1] <- "nmc"
colnames(data.m)[2] <- "Current_status"
library(ggplot2)
ggplot(data=data.m, aes(x=nmc, y=value, fill=Current_status)) +
geom_bar(stat="identity")+
# geom_text(aes(y=label_ypos, label=len), vjust=1.6,
#          color="white", size=3.5)+
#scale_fill_brewer(palette="Paired")+
theme_minimal()+
scale_x_continuous(breaks=seq(1,17,2))+
ggtitle("LIFE study summary")+
xlab("Number of menstrucal cycle")+
ylab("Number of people")
ID <- unique(data$ID)
ID <- sort(ID)
obs <- rep(0,n.sub)
N <- rep(0,n.sub)
for(i in 1:n.sub){
print(i)
idx <- which(data$ID==ID[i])
obs[i] <- max(data[idx,]$preg,na.rm=T)
N[i] <- max(data[idx,]$method5,na.rm=T)
}
data.temp <- cbind(ID,obs,N)
data.com <- merge(data.temp,data.baseline,by.x="ID",by.y="ID")
library(tidyverse)
library(dplyr)
data.com <- data.com %>% mutate(
age_average = (Age_m+Age_f)/2,
age_diff = abs(Age_m-Age_f)/2
)
idx <- which(data.com$N!=0)
data.clean <- data.com[idx,]
dim(data.clean)
n.couple <- nrow(data.clean)
n.cycle <- sum(data.clean$N)
Y <- rep(0,n.cycle)
age_averge.cycle <- rep(0,n.cycle)
age_diff.cycle <- rep(0,n.cycle)
ID.cycle <- rep(0,n.cycle)
temp <- 0
for(i in 1:n.couple){
print(i)
if(data.clean$obs[i]==1){
Y[temp] = 1
}
age_averge.cycle[temp+(1:data.clean$N[i])] <- data.clean$age_average[i]
age_diff.cycle[temp+(1:data.clean$N[i])] <- data.clean$age_diff[i]
ID.cycle[temp+(1:data.clean$N[i])] <- data.clean$ID[i]
temp <- temp+data.clean$N[i]
}
###############logistic regression adjusting for age average and age difference
model.logistic <- glm(Y~age_averge.cycle+age_diff.cycle)
summary(model.logistic)
exp(0.355982)/(1+exp(0.355982))
summary(model.logistic)
confint(model.logistic)
##############mixed effect logistic regression allowing for sample difference
library(lme4)
install.packages("lme4")
##############mixed effect logistic regression allowing for sample difference
library(lme4)
model.mix.logistic <- glmer(Y~(1|ID.cycle)+age_averge.cycle+age_diff.cycle,family = binomial)
summary(model.mix.logistic)
# method function ---------------------------------------------------------
source("logistic_support.R")
i1 = 1
i2 = 1
i3 = 1
i4 =1
# method function ---------------------------------------------------------
source("logistic_support.R")
source("logistic_NPML.R")
getwd()
# method function ---------------------------------------------------------
source("./code/logistic_support.R")
source("./code/logistic_NPML.R")
install.packages("nleqslv")
library(nleqslv)
source("./code/logistic_NPML.R")
# method function ---------------------------------------------------------
source("./code/logistic_support.R")
install.packages("SQUAREM")
# method function ---------------------------------------------------------
source("./code/logistic_support.R")
source("./code/logistic_NPML.R")
install.packages("car")
# method function ---------------------------------------------------------
source("./code/logistic_support.R")
source("./code/logistic_NPML.R")
source("./code/logistic_NPML.R")
R <- 400
observation=2
K_vector <- c(16,32,48,64,80,96,112)
sd_u_vector <- c(0,1,3,5)
r_vector <- c(0,0.4,0.8)
beta_vector <- c(0,0.5,1)
set.seed(123)
logistic_result <- NULL
indicator <- 1
K <- K_vector[i1]
sd_u <- sd_u_vector[i2]
r <- r_vector[i3]
beta <- beta_vector[i4]
mu_u <- 0
u_new_min <- logit(0.02)+beta*1.5
u_new_max <- logit(0.98)-beta*1.5
data <- generating(mu_u,sd_u,K,r,beta,R,observation)
u_new <- data$u_new
x <- data$x
theta <- data$theta
NTL <- data$NTL
subjects <- NULL
for(i in 1:observation){
subjects <- rbind(subjects,c(1:K))
}
subjects <- as.vector(subjects)
param.start <- c(mean(u_new),beta)
tol <- 1e-07
maxit <- 500
ran_standard_logistic_results <- apply(NTL,1,function(y){random_glm(y,x,subjects)})
# method function ---------------------------------------------------------
source("./code/logistic_support.R")
source("./code/logistic_NPML.R")
R <- 400
observation=2
K_vector <- c(16,32,48,64,80,96,112)
sd_u_vector <- c(0,1,3,5)
r_vector <- c(0,0.4,0.8)
beta_vector <- c(0,0.5,1)
set.seed(123)
logistic_result <- NULL
indicator <- 1
K <- K_vector[i1]
sd_u <- sd_u_vector[i2]
r <- r_vector[i3]
beta <- beta_vector[i4]
mu_u <- 0
u_new_min <- logit(0.02)+beta*1.5
u_new_max <- logit(0.98)-beta*1.5
data <- generating(mu_u,sd_u,K,r,beta,R,observation)
u_new <- data$u_new
x <- data$x
theta <- data$theta
NTL <- data$NTL
subjects <- NULL
for(i in 1:observation){
subjects <- rbind(subjects,c(1:K))
}
subjects <- as.vector(subjects)
param.start <- c(mean(u_new),beta)
tol <- 1e-07
maxit <- 500
ran_standard_logistic_results <- apply(NTL,1,function(y){random_glm(y,x,subjects)})
idx_logistic <- ran_standard_logistic_results[3,]
true_u <- mean(u_new)
dim(NTL)
NPML_logistic_function(NTL[1,],x,tol,maxit,K,observation)
NTL[1,]
NPML_logistic_function(NTL[1,],x,tol,maxit,K,observation)
i1 = 4
R <- 400
observation=2
K_vector <- c(16,32,48,64,80,96,112)
sd_u_vector <- c(0,1,3,5)
r_vector <- c(0,0.4,0.8)
beta_vector <- c(0,0.5,1)
set.seed(123)
logistic_result <- NULL
indicator <- 1
K <- K_vector[i1]
sd_u <- sd_u_vector[i2]
r <- r_vector[i3]
beta <- beta_vector[i4]
mu_u <- 0
u_new_min <- logit(0.02)+beta*1.5
u_new_max <- logit(0.98)-beta*1.5
data <- generating(mu_u,sd_u,K,r,beta,R,observation)
u_new <- data$u_new
x <- data$x
theta <- data$theta
NTL <- data$NTL
subjects <- NULL
for(i in 1:observation){
subjects <- rbind(subjects,c(1:K))
}
subjects <- as.vector(subjects)
param.start <- c(mean(u_new),beta)
tol <- 1e-07
maxit <- 500
NPML_logistic_function(NTL[1,],x,tol,maxit,K,observation)
head(x)
head(N)
